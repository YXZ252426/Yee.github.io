---
title: 一个c程序的奇妙漂流
date: 2025-11-19 15:33:41
tags:
---

> 详细介绍一个c语言代码的完整生命周期，从写好后被编译的各个过程，elf被execve启动为一个进程的各个过程以及最终到最底层cpu逐个取指的过程

> C 源码 ➜ 预处理 ➜ 编译成汇编 ➜ 汇编成 .o(ELF 目标文件) ➜ 链接成 ELF 可执行文件 ➜ `execve` 装载成进程 ➜ CPU 不停取指执行

---

## 0\. 先定个例子

```c
// main.c
#include <stdio.h>

int g_init = 10;          // 已初始化全局变量 -> .data
int g_uninit;             // 未初始化全局变量 -> .bss
const char msg[] = "hi";  // 字符串常量       -> .rodata

int main() {
    int x = 1;            // 局部变量 -> 栈
    printf("%s %d\n", msg, g_init + x);
    return 0;
}
```

在 Linux 下：

```bash
gcc main.c -o main
```

会经历下面所有步骤。

---

## 1\. 从 `.c` 到汇编：预处理 + 编译

### 1.1 预处理（Preprocessing）

命令：

```bash
gcc -E main.c -o main.i
```

做的事：

-   展开 `#include <stdio.h>`：把头文件内容直接“拷贝”进来
    
-   展开 `#define` 宏
    
-   处理 `#if/#ifdef` 条件编译
    

得到一个**巨大的纯 C 文件** `main.i`（你一般不会去看）。

### 1.2 编译（Compilation，本质：高级语言 → 汇编）

命令：

```bash
gcc -S main.i -o main.s
# 常用：gcc -S main.c  也会自动包含预处理
```

编译器做的事情可以对应到“编译原理”课程：

1.  词法分析：把字符流 → token（关键字、标识符、运算符…）
    
2.  语法分析：根据文法生成语法树 AST
    
3.  语义分析：类型检查、作用域检查等
    
4.  中间代码 IR：例如 SSA 形式的中间表示
    
5.  各种优化：常量传播、死代码删除、循环优化……
    
6.  后端生成**汇编代码**：比如 x86-64 的指令
    

生成 `.s` 汇编文件，比如你会看到类似：

```asm
.file   "main.c"
    .globl  g_init
g_init:
    .long   10
    .comm   g_uninit,4,4
    .section    .rodata
.LC0:
    .string "hi %d\n"
    .text
    .globl  main
main:
    ; 这里是 main 的指令...
```

---

## 2\. 从汇编到 `.o`：汇编器生成 ELF 目标文件

命令：

```bash
gcc -c main.s -o main.o
# 通常你直接用：gcc -c main.c -o main.o   也会自动包含前两步
```

这一步使用的是 **Assembler（汇编器）**，例如 `as`。

`main.o` 是一个 **ELF 目标文件（Relocatable，ET\_REL）**

用：

```bash
readelf -h main.o       # ELF 头
readelf -S main.o       # Section Headers
```

可以看到：

-   `.text`：指令（main 函数的机器码）
    
-   `.data`：已初始化全局变量（`g_init = 10`）
    
-   `.bss`：未初始化全局变量（`g_uninit`，NOBITS，运行时分配为 0）
    
-   `.rodata`：只读常量（`"hi"`）
    
-   `.symtab`：符号表（`main`、`g_init`、`printf` 等符号）
    
-   `.rel.text` / `.rela.text`：**重定位信息**（比如 `printf` 在这里仅是“将来要填的地址”）
    

此时的 `.o` **还不能直接执行**，因为：

-   所有地址都是“相对”的，程序还没被安排到进程虚拟地址空间的具体位置
    
-   外部符号（如 `printf`）还不知道在 libc 里面的具体地址
    

---

## 3\. 链接：多个 `.o` + 库 → 一个可执行 ELF

命令（最常用的那句）：

```bash
gcc main.o -o main
# 实际上等价于调用 ld 进行链接
```

链接器（`ld`）主要做三件事：

### 3.1 “拼版”：把各个段连成一片

比如你有多个 `.o`：`main.o`, `foo.o`，还有静态库 `libxxx.a`：

-   把所有 `.text` 段拼起来，形成最终可执行文件的 `.text`
    
-   把所有 `.data` 拼成最终 `.data`
    
-   `.bss` 同理
    
-   重新安排它们在虚拟地址空间中的**线性布局**，决定每个段“将来要映射到的虚拟地址”
    

### 3.2 解析符号 + 重定位

-   在每个 `.o` 里，`call printf` 是一个“**还没定死**”的地址
    
-   链接器遍历各个 `.o` 和库中的**符号表**：
    
    -   找到 `printf` 实际来自哪儿（静态链接：libc.a；动态链接：留给动态链接器）
        
-   把 `.rel.text` 里的“占位符”用**真正的地址或者重定位形式**填上
    
-   这一步是你看到的“重定位（relocation）”
    

### 3.3 生成 ELF 可执行文件（ET\_EXEC 或 ET\_DYN）

最终的 `main` 是一个 **ELF 可执行文件**，用 `readelf -h main` 你会看到：

-   `Type: DYN (Shared object file)` 现在很多是 PIE，可执行文件也是 ET\_DYN
    
-   Program Header Table（程序头表）：给**内核/装载器**看的
    
    -   哪些是 `PT_LOAD`（要加载的段）
        
    -   代码段：只读可执行（RX）
        
    -   数据段：可读可写（RW）
        
-   Section Header Table（节头表）：给**链接器和调试器**看的
    

还有一项很关键：

-   `Entry point address:` （入口地址）  
    — 通常不是 `main`，而是 `_start`（C 运行时入口）
    

如果是动态链接，还会有：

-   `PT_INTERP` 段里写着动态链接器（如 `/lib64/ld-linux-x86-64.so.2`）
    

---

## 4\. 从 ELF 到进程：`execve` 装载过程

### 4.1 Shell 做了啥？

你在终端敲：

```bash
./main
```

Shell 做的典型流程是：

1.  调用 `fork()`：复制出一个“子进程”，子进程几乎继承了父进程（shell）的地址空间
    
2.  子进程里调用 `execve("./main", argv, envp)` 系统调用
    
3.  如果 `execve` 成功：
    
    -   原来子进程里的代码和地址空间被**完全替换**成 `main` 这个程序
        
    -   只保留了 PID、打开的文件描述符（有一些规则）、信号处理器重置等
        

### 4.2 `execve` 在内核中做了什么？

非常关键的一步，它把 **“ELF 文件”变成“正在运行的进程”**。

大致步骤（简化的 Linux 视角）：

1.  **检查文件**：路径解析、权限检查（可执行位）
    
2.  **识别 ELF**：
    
    -   读 ELF 头部的 `Magic: 0x7f 'E' 'L' 'F'`
        
    -   根据 Program Header Table 确定哪些段需要加载、权限怎样
        
3.  **销毁旧的地址空间**：把原来子进程的虚拟内存映射全部释放掉（除了内核部分）
    
4.  **创建新的虚拟地址空间**：
    
    -   为代码段（text segment）创建 VMA：虚拟地址范围 + 权限（RX）
        
    -   为数据段（data / rodata）创建 VMA：地址 + 权限（RW 或 R）
        
    -   为 BSS 创建匿名映射并置零（NOBITS 段）
        
    -   建立一个初始栈 VMA（高地址附近，RW）
        
    -   这些 VMA 通过页表映射到物理页（很多是**按需分页**：第一次访问才真正读磁盘）
        
5.  **把 argv / envp / 辅助信息压到用户栈**：
    
    -   在用户态栈上放好：
        
        -   `argc`
            
        -   `argv[0..argc-1]`
            
        -   `envp`
            
        -   `auxv`（一些系统级信息，比如页大小、系统调用入口等）
            
6.  **处理动态链接**：
    
    -   如果 ELF 里有 `PT_INTERP`：
        
        -   先把动态链接器 `ld-linux-x86-64.so.2` （也是一个 ELF）映射到内存
            
        -   `execve` 把 CPU 的下一条指令入口指向动态链接器的入口（不是你的 `main`、也不是 `_start`）
            
7.  **设置 CPU 上下文**：
    
    -   设置程序计数器（PC / RIP）为入口地址（比如动态链接器）
        
    -   设置栈指针（SP / RSP）指向刚才布置好的用户栈顶
        
    -   切换到**用户态**，开始执行用户程序第一条指令
        

到这一步：  
**内核已经帮你把 ELF → 进程（有独立虚拟地址空间 + 栈 + 各种段映射）**。

---

## 5\. 动态链接器 & C 运行时：从 `_start` 到 `main`

### 5.1 动态链接器干啥？

动态链接器（`ld-linux-xxx.so`）在用户态做：

1.  读 ELF 里的 `.dynamic` / `.dynsym` 等信息，找到需要的共享库 (`libc.so.6` 等)
    
2.  `mmap` 这些 `.so` 到地址空间
    
3.  做**重定位**：
    
    -   把 GOT/PLT、全局变量引用等全部修正为正确地址
        
4.  调用 ELF 里的入口 `_start`（通常从 `crt1.o` 来）
    

所以：  
**真正跑到你程序 `_start` 的时候，所有动态库、重定位基本都已经搞定**（懒绑定除外）。

### 5.2 `_start` → `__libc_start_main` → `main`

`_start` 是一小段汇编：

-   设置好栈帧
    
-   把 `argc/argv` 取出来
    
-   调用 GLIBC 提供的 `__libc_start_main(main, ...)`
    

`__libc_start_main` 做的事包括：

1.  初始化 C 运行时环境（TLS、locale 等）
    
2.  调用全局构造函数（C++ 的全局对象构造、`.init_array` 段）
    
3.  调用你的 `main(argc, argv, envp)`
    
4.  `main` 返回后调用 `exit()` 做清理：
    
    -   执行 `atexit` 注册的回调
        
    -   刷新并关闭 `stdio` 缓冲
        
    -   最后调用 `_exit(status)` 系统调用 → 回到内核
        

---

## 6\. 进程视角 vs 操作系统视角 vs CPU 视角

### 6.1 进程视角（你在写 C 程序时看到的世界）

-   一个连续的**虚拟地址空间**：
    
    -   \[低地址\] 代码段（text）
        
    -   数据段（data）
        
    -   BSS
        
    -   堆（heap，`brk/mmap` 往上长）
        
    -   映射的共享库
        
    -   栈（stack，从高地址往下长）
        
-   有自己的 PID、打开的文件、信号处理器等
    

你感觉：这个世界只有你一个程序，地址都是“从 0 开始”的样子。

### 6.2 操作系统视角（OS）

OS 管理的是：

-   一堆进程（每个有 PCB：寄存器快照、页表指针、状态等）
    
-   每个进程的页表（虚拟地址 → 物理地址映射）
    
-   调度：在众多进程之间分配 CPU 时间片
    
-   I/O、文件系统、网络等资源
    

当发生 **上下文切换** 时：

1.  保存当前正在运行进程的寄存器（PC、SP、通用寄存器等）
    
2.  换一套寄存器值为下一个进程的
    
3.  切换页表基址寄存器（如 x86 的 CR3）
    
4.  CPU 再继续“取指”，但此时同一个虚拟地址对应的是别的进程的物理内存
    

### 6.3 CPU 视角（最底层）

对 CPU 来说，它**完全不知道“进程”是什么**。  
它看到的只有：

-   当前这套寄存器的值
    
-   当前的页表基址
    
-   取指地址（PC）
    

接下来就是经典的：

---

## 7\. 最底层：CPU 的“取指-执行”循环

无论你的 C 程序多复杂，在 CPU 看来都是无限重复的：

> **取指（Fetch）→ 译码（Decode）→ 执行（Execute）→ 访存（Memory）→ 写回（Write-back）**

简化解释一下：

1.  **取指（IF）**：
    
    -   用 PC（程序计数器）中的虚拟地址，到内存取一条指令
        
    -   先查 TLB，把虚拟地址翻译成物理地址
        
    -   再从 L1/L2 cache 或内存里读出指令，放到指令寄存器（IR）
        
2.  **译码（ID）**：
    
    -   硬件根据指令格式，解析出操作码、源寄存器、目的寄存器、立即数等
        
3.  **取寄存器操作数**：
    
    -   从通用寄存器堆读出需要的值（比如 `%rax`、`%rbx`）
        
4.  **执行（EX）**：
    
    -   交给 ALU 做运算（加减乘除、逻辑运算、比较……）
        
    -   或者计算内存地址（基址 + 偏移）
        
5.  **访存（MEM）**：
    
    -   对于 load/store 指令，通过 MMU（TLB + 页表）访问数据地址
        
    -   这个阶段也会用到 cache，如果 cache miss 就要访问主存
        
6.  **写回（WB）**：
    
    -   把结果写回目标寄存器或内存
        
7.  **更新 PC**：
    
    -   一般 `PC = PC + 指令长度`
        
    -   遇到跳转/调用/返回：PC 改成新的目标地址（涉及分支预测等高阶内容）
        

这就是你在《计算机组成原理》看到的“多级流水线、取指部件、控制器、ALU、寄存器堆、MMU”等的实际工作场景。

---

## 8\. 把所有课程串起来回顾一遍

这条路径几乎把几门核心课全串上了：

-   **C 语言 + 编译原理**
    
    -   预处理、词法语法分析、IR、优化、汇编生成
        
-   **操作系统**
    
    -   进程、虚拟内存、页表、系统调用、`execve`、`fork`
        
-   **计算机组成原理**
    
    -   指令系统、寄存器、流水线、取指-执行循环、MMU/TLB、缓存
        
-   **计算机网络（顺带）**
    
    -   程序里调用 `read`/`write` 操作 socket，其实是通过系统调用让内核驱动网卡收发包
        

---